#![allow(dead_code)]
use super::*;
pub struct GCodeCreator<T : std::io::Write> {
    cnc_router: cnc_router::CNCRouter<T>,
    start_middle: bool,
    spindle_speed: f64,
    feed_rate: f64,
    z_axis_off_cut: f64,
    depth_of_cut: f64,
}

impl <T: std::io::Write> GCodeCreator<T> {
    pub fn from(cnc_router: cnc_router::CNCRouter<T>,
        use_inches: bool, start_middle: bool, spindle_speed: f64,
        feed_rate: f64, z_axis_off_cut: f64, depth_of_cut: f64,
    ) -> GCodeCreator<T> {

        let mut gc = GCodeCreator {
            cnc_router: cnc_router,
            start_middle: start_middle,
            spindle_speed: spindle_speed,
            feed_rate: feed_rate,
            z_axis_off_cut: z_axis_off_cut,
            depth_of_cut: depth_of_cut
        };

        if gc.cnc_router.get_verbose() {
            gc.cnc_router.write_gcode_string(String::from("%"));
            gc.cnc_router.write_gcode_string(String::from(" (Header)"));
            gc.cnc_router.write_gcode_string(String::from(" (Generated by camcam from Asante Sign Group.)"));
        }

        gc.cnc_router.generate_header(use_inches);

        return gc;
    }

    pub fn is_down(&self, tool_length: f64) -> bool {
        let z = self.cnc_router.get_pos().z + tool_length;
        (z > self.z_axis_off_cut && self.depth_of_cut > 0.0) ||
            (z < self.z_axis_off_cut && self.depth_of_cut < 0.0)
    }

    pub fn build_gcode_around_lines<J> (
        &mut self,
        feed_rate: f64,
        path: &Vec<J>,
        follow_path: &Box<impl Fn (&mut cnc_router::CNCRouter<T>, &J, f64)>,
    ) {
        for j in path {
            follow_path(&mut self.cnc_router, &j, feed_rate);
        }
    }

    pub fn build_gcode<J : lines_and_curves::Intersection + std::fmt::Debug + Clone> (
        &mut self,
        next_path : fn (&mut bit_path::PathItr<f64>) -> bool,
        signs : &mut Vec<sign::Sign<J> >,
        start_path: &Box<impl Fn (&J) -> lines_and_curves::Point >,
        follow_path: &Box<impl Fn (&mut cnc_router::CNCRouter<T>, &J, f64)>,
    ) {
        let tools = self.cnc_router.get_tools().clone();
        for sign in &mut *signs {
            let mut cuttable_rects = vec![
                sign.bounding_rect().clone(),
            ];
            let mut seen_full_broad = false;

            for (tool_index, tool) in tools.iter().enumerate() {
                if !tool.is_broad() { continue; }
                let depth_of_cut = self.depth_of_cut;
                let z_axis_off_cut = self.z_axis_off_cut + tool.length; 
                if !seen_full_broad {
                    cuttable_rects = vec![
                        sign.bounding_rect().clone(),
                    ];
                }
                eprintln!("{} {}", seen_full_broad, cuttable_rects.len());
                if let cnc_router::ToolType::FullCutBroad = tool.tool_type {
                    seen_full_broad = true;
                }
                self.cnc_router.write_gcode_comment(format!("CHANGED TOOL {}", tool_index));

                self.cnc_router.set_tool_and_go_home(tool_index, tool.feed_rate_of_cut);
                self.cnc_router.set_spindle_on(false, self.spindle_speed);
                let bit_diameter = 2.0 * tool.radius;

                let mut new_cuttable_rects = lines_and_curves::RectangleConnections::from(
                    bit_diameter, bit_diameter,
                    sign.bounding_rect().clone()
                );

                for cut_rect in cuttable_rects {
                    let sign_width = cut_rect.width(); // sign.bounding_rect().width();
                    let sign_height = cut_rect.height(); // sign.bounding_rect().height();
                    let width = (cut_rect.width() / bit_diameter) as usize;
                    let height = (cut_rect.height() / bit_diameter) as usize;
                    let min_x = cut_rect.min_x();
                    let min_y = cut_rect.min_y();

                    let mut path = bit_path::Path::from(
                        width,
                        height,
                        Box::from(move |x : usize, y: usize| -> (f64, f64) {
                            ((x as f64 / width as f64) as f64 * sign_width + min_x,
                                (y as f64 / height as f64) as f64 * sign_height + min_y)
                        }),
                        next_path
                    );
                    if self.start_middle {
                        path = path.start_middle();
                    }
                    let mut cut_to : Option<lines_and_curves::Point> = None;
                    for (x, y, can_be_down) in path {
                        let seen = sign.y_values_before(x, y);
                        let rect = lines_and_curves::Rectangle::from(
                            lines_and_curves::Point::from(
                                x - bit_diameter/2.0,
                                y - bit_diameter/2.0,
                            ),
                            lines_and_curves::Point::from(
                                x + bit_diameter/2.0,
                                y + bit_diameter/2.0,
                            ),
                        );

                        let crosses_rect = sign.line_collides_wth_rect(&rect);
                        let is_down = can_be_down && (seen % 2 == 0) && !crosses_rect;
                        if crosses_rect {
                            new_cuttable_rects.add_rect(&lines_and_curves::Point::from(x,y));
                        }

                        if is_down {
                            if let Some(p) = cut_to {
                                assert!(self.is_down(tool.length));
                                if !lines_and_curves::LineSegment::from(
                                    self.cnc_router.get_point(),
                                    lines_and_curves::Point::from(x, y)
                                ).contains_point_endless_line(p) {
                                    new_cuttable_rects.add_rect(&lines_and_curves::Point::from(p.x,p.y));
                                    self.cnc_router.move_to_coordinate(
                                        &cnc_router::Coordinate::from(
                                            p.x, p.y, z_axis_off_cut + depth_of_cut,
                                        ),
                                        tool.feed_rate_of_cut, false,
                                    );
                                } 
                            } else {
                                assert!(!self.is_down(tool.length));
                                // removing this as it adds in unnecessary fillers on paths
                                // with horizontal lines
                                // new_cuttable_rects.add_rect(&lines_and_curves::Point::from(x, y));
                                self.cnc_router.move_to_coordinate_rapid(
                                    &cnc_router::Coordinate::from(
                                        x, y, z_axis_off_cut,
                                    ),
                                );
                                self.cnc_router.move_to_coordinate(
                                    &cnc_router::Coordinate::from(
                                        x, y, z_axis_off_cut + depth_of_cut,
                                    ),
                                    tool.feed_rate_of_drill, false,
                                );
                            }

                            cut_to = Some(lines_and_curves::Point::from(x, y));
                        } else {
                            if let Some(p) = cut_to {
                                assert!(self.is_down(tool.length));
                                self.cnc_router.move_to_coordinate(
                                    &cnc_router::Coordinate::from(
                                        p.x, p.y, z_axis_off_cut + depth_of_cut,
                                    ),
                                    tool.feed_rate_of_cut, false,
                                );
                                self.cnc_router.move_to_coordinate(
                                    &cnc_router::Coordinate::from(
                                        p.x, p.y, z_axis_off_cut,
                                    ),
                                    tool.feed_rate_of_cut, false,
                                );
                            }
                            cut_to = None;
                        }
                    }

                    if self.is_down(tool.length) {
                        if let Some(p) = cut_to {
                            self.cnc_router.move_to_coordinate(
                                &cnc_router::Coordinate::from(
                                p.x, p.y, z_axis_off_cut + depth_of_cut),
                                tool.feed_rate_of_cut, false,
                            );
                        }
                    }
                    self.cnc_router.move_to_coordinate(
                        &cnc_router::Coordinate::from(
                            self.cnc_router.get_pos().x, self.cnc_router.get_pos().y, z_axis_off_cut
                        ),
                        tool.feed_rate_of_cut, false,
                    );
                }

                let mut new_rects = Vec::new();
                new_cuttable_rects.to_bigger_rect_iter();
                new_rects.extend(new_cuttable_rects);
                cuttable_rects = new_rects;

                self.cnc_router.set_spindle_off();
            }
        }

        self.cnc_router.write_gcode_comment_str("Following Shapes");
        for (tool_index, tool) in tools.iter().enumerate() {
            if !tool.is_text() {
                continue
            }
            let z_axis_off_cut = self.z_axis_off_cut + tool.length; 
            self.cnc_router.set_tool_and_go_home(tool_index, tool.feed_rate_of_cut);
            for sign in &mut *signs {
                for shape in sign.shapes() {
                    let point = start_path(&shape.lines()[0]);
                    self.cnc_router.start_cutting_at(
                        &cnc_router::Coordinate::from(
                            point.x, point.y,
                            z_axis_off_cut + self.depth_of_cut
                        ),
                        tool.feed_rate_of_drill, false
                    );
                    self.build_gcode_around_lines(
                        tool.feed_rate_of_cut,
                        shape.lines(), follow_path,
                    );
                }
            }
        }


        self.cnc_router.go_home();
        self.cnc_router.set_spindle_off();
        self.cnc_router.reset_program_and_end();
    }

    pub fn get_router(&self) -> &cnc_router::CNCRouter<T> {
        &self.cnc_router
    }

    pub fn get_router_mut(&mut self) -> &mut cnc_router::CNCRouter<T> {
        &mut self.cnc_router
    }
}

