#![allow(dead_code)]
use super::*;
pub struct GCodeCreator<T : std::io::Write> {
    cnc_router: cnc_router::CNCRouter<T>,
    start_middle: bool,
    spindle_speed: f64,
    feed_rate: f64,
    z_axis_off_cut: f64,
    depth_of_cut: f64,
}

impl <T: std::io::Write> GCodeCreator<T> {
    pub fn from(cnc_router: cnc_router::CNCRouter<T>,
        use_inches: bool, start_middle: bool, spindle_speed: f64,
        feed_rate: f64, z_axis_off_cut: f64, depth_of_cut: f64,
    ) -> GCodeCreator<T> {
        let mut gc = GCodeCreator {
            cnc_router: cnc_router,
            start_middle: start_middle,
            spindle_speed: spindle_speed,
            feed_rate: feed_rate,
            z_axis_off_cut: z_axis_off_cut,
            depth_of_cut: depth_of_cut
        };

        if gc.cnc_router.get_verbose() {
            gc.cnc_router.write_gcode_string(String::from("%"));
            gc.cnc_router.write_gcode_string(String::from(" (Header)"));
            gc.cnc_router.write_gcode_string(String::from(" (Generated by camcam from Asante Sign Group.)"));
        }

        gc.cnc_router.generate_header(use_inches);

        return gc;
    }

    pub fn is_down(&self, tool_length: f64) -> bool {
        let z = self.cnc_router.get_pos().z + tool_length;
        (z > self.z_axis_off_cut && self.depth_of_cut > 0.0) ||
            (z < self.z_axis_off_cut && self.depth_of_cut < 0.0)
    }

    pub fn build_gcode<J : lines_and_curves::Intersection +
        std::fmt::Debug + Clone + cnc_router::CNCPath> (
        &mut self,
        do_cut_on_odd: bool,
        next_path : fn (&mut bit_path::PathItr<f64>) -> bool,
        signs : &mut Vec<sign::Sign<J> >,
    ) {
        let tools = self.cnc_router.get_tools().clone();
        for sign in &mut *signs {
            let mut cuttable_rects = vec![
                sign.bounding_rect().clone(),
            ];
            let mut seen_full_broad = false;

            for (tool_index, tool) in tools.iter().enumerate() {
                if !tool.is_broad() { continue; }
                let depth_of_cut = self.depth_of_cut;
                let z_axis_off_cut = self.z_axis_off_cut + tool.length; 
                if !seen_full_broad {
                    cuttable_rects = vec![
                        sign.bounding_rect().clone(),
                    ];
                }
                // eprintln!("{} {}", seen_full_broad, cuttable_rects.len());
                if let cnc_router::ToolType::FullCutBroad = tool.tool_type {
                    seen_full_broad = true;
                }
                self.cnc_router.write_gcode_comment(format!("CHANGED TOOL {}", tool_index));

                self.cnc_router.set_tool_and_go_home(tool_index, tool.feed_rate_of_cut);
                self.cnc_router.set_spindle_on(false, self.spindle_speed);
                let bit_diameter = 2.0 * tool.radius;

                let mut new_cuttable_rects = lines_and_curves::RectangleConnections::from(
                    bit_diameter, bit_diameter,
                    sign.bounding_rect().clone()
                );

                for cut_rect in cuttable_rects {
                    let sign_width = cut_rect.width(); // sign.bounding_rect().width();
                    let sign_height = cut_rect.height(); // sign.bounding_rect().height();
                    let width = (cut_rect.width() / (bit_diameter * tool.offset)) as usize;
                    let height = (cut_rect.height() / (bit_diameter * tool.offset)) as usize;
                    let min_x = cut_rect.min_x();
                    let min_y = cut_rect.min_y();

                    let mut path = bit_path::Path::from(
                        width,
                        height,
                        Box::from(move |x : usize, y: usize| -> (f64, f64) {
                            ((x as f64 / width as f64) as f64 * sign_width + min_x,
                                (y as f64 / height as f64) as f64 * sign_height + min_y)
                        }),
                        next_path
                    );
                    if self.start_middle {
                        path = path.start_middle();
                    }
                    let mut cut_to : Option<lines_and_curves::Point> = None;
                    for (x, y, can_be_down) in path {
                        let seen = sign.y_values_before(x, y);
                        let rect = lines_and_curves::Rectangle::from(
                            lines_and_curves::Point::from(
                                x - bit_diameter/2.0,
                                y - bit_diameter/2.0,
                            ),
                            lines_and_curves::Point::from(
                                x + bit_diameter/2.0,
                                y + bit_diameter/2.0,
                            ),
                        );

                        let crosses_rect = sign.line_collides_wth_rect(&rect);
                        let is_down = can_be_down &&
                            ((seen % 2 == 1) == do_cut_on_odd) && !crosses_rect;
                        if crosses_rect {
                            new_cuttable_rects.add_rect(&lines_and_curves::Point::from(x,y));
                        }

                        if is_down {
                            if let Some(p) = cut_to {
                                assert!(self.is_down(tool.length));
                                if !lines_and_curves::LineSegment::from(
                                    self.cnc_router.get_point(),
                                    lines_and_curves::Point::from(x, y)
                                ).contains_point_endless_line(p) {
                                    new_cuttable_rects.add_rect(&lines_and_curves::Point::from(p.x,p.y));
                                    self.cnc_router.move_to_optional_coordinate(
                                        &cnc_router::OptionalCoordinate::from(
                                            Some(p.x), Some(p.y), None,
                                        ),
                                        Some(tool.feed_rate_of_cut), false,
                                    );
                                }
                            } else {
                                assert!(!self.is_down(tool.length));
                                // removing this as it adds in unnecessary fillers on paths
                                // with horizontal lines
                                // new_cuttable_rects.add_rect(&lines_and_curves::Point::from(x, y));
                                self.cnc_router.move_to_coordinate_rapid(
                                    &cnc_router::Coordinate::from(
                                        x, y, z_axis_off_cut,
                                    ),
                                );
                                self.cnc_router.move_to_optional_coordinate(
                                    &cnc_router::OptionalCoordinate::from_z(
                                        Some(z_axis_off_cut + depth_of_cut),
                                    ),
                                    Some(tool.feed_rate_of_drill), false,
                                );
                            }

                            cut_to = Some(lines_and_curves::Point::from(x, y));
                        } else {
                            if let Some(p) = cut_to {
                                assert!(self.is_down(tool.length));
                                self.cnc_router.move_to_optional_coordinate(
                                    &cnc_router::OptionalCoordinate::from(
                                        Some(p.x), Some(p.y), None
                                    ),
                                    Some(tool.feed_rate_of_cut), false,
                                );
                                self.cnc_router.move_to_optional_coordinate(
                                    &cnc_router::OptionalCoordinate::from_z(
                                        Some(z_axis_off_cut),
                                    ),
                                    None, false,
                                );
                            }
                            cut_to = None;
                        }
                    }

                    if self.is_down(tool.length) {
                        if let Some(p) = cut_to {
                            self.cnc_router.move_to_optional_coordinate(
                                &cnc_router::OptionalCoordinate::from(
                                    Some(p.x), Some(p.y), None,
                                ),
                                Some(tool.feed_rate_of_cut), false,
                            );
                        }
                    }
                    self.cnc_router.move_to_optional_coordinate(
                        &cnc_router::OptionalCoordinate::from_z(
                            Some(z_axis_off_cut)
                        ),
                        Some(tool.feed_rate_of_cut), false,
                    );
                }

                let mut new_rects = Vec::new();
                new_cuttable_rects.to_bigger_rect_iter();
                new_rects.extend(new_cuttable_rects);
                cuttable_rects = new_rects;

                self.cnc_router.set_spindle_off();
            }
        }

        self.cnc_router.write_gcode_comment_str("Following Shapes");
        for tool_type in vec![cnc_router::ToolType::Text, cnc_router::ToolType::Braille] {
            for (tool_index, tool) in tools.iter().enumerate() {
                if tool_type.raw_value() != tool.tool_type.raw_value() {
                    continue;
                }

                let z_axis_off_cut = self.z_axis_off_cut + tool.length; 
                self.cnc_router.set_tool_and_go_home(tool_index, tool.feed_rate_of_cut);
                self.cnc_router.set_spindle_on(false, self.spindle_speed);
                for sign in &mut *signs {
                    for shape in sign.shapes() {
                        let mut first_line = true;
                        for line in shape.lines() {
                            if first_line || !line.is_connected() {
                                first_line = false;
                                let Some(point) = line.start_path() else {
                                    continue;
                                };
                                self.cnc_router.move_to_coordinate_rapid(
                                    &cnc_router::Coordinate::from(
                                        point.x, point.y,
                                        z_axis_off_cut
                                    ),
                                );
                                self.cnc_router.move_to_coordinate(
                                    &cnc_router::Coordinate::from(
                                        point.x, point.y,
                                        z_axis_off_cut + self.depth_of_cut,
                                    ),
                                    Some(tool.feed_rate_of_drill), false
                                );
                            }
                            line.follow_path(&mut self.cnc_router, Some(tool.feed_rate_of_cut));
                            if !line.is_connected() {
                                self.cnc_router.move_to_optional_coordinate(
                                    &cnc_router::OptionalCoordinate::from_z(
                                        Some(z_axis_off_cut)
                                    ),
                                    Some(tool.feed_rate_of_drill), false
                                );
                            }
                        }
                        if self.is_down(tool.length) {
                            self.cnc_router.move_to_optional_coordinate(
                                &cnc_router::OptionalCoordinate::from_z(
                                    Some(z_axis_off_cut)
                                ),
                                Some(tool.feed_rate_of_drill), false
                            );
                        }
                    }
                }
                self.cnc_router.set_spindle_off();
            }
        }

        self.cnc_router.go_home();
        self.cnc_router.set_spindle_off();
        self.cnc_router.reset_program_and_end();
    }

    pub fn cut_broad_rect<J : lines_and_curves::Intersection +
        std::fmt::Debug + Clone + cnc_router::CNCPath> (
        &mut self,
        do_cut_on_odd: bool,
        sign : &mut sign::Sign<J>,
        tool: &cnc_router::Tool,
        rect: &lines_and_curves::Rectangle,
        range_map: &mut range_map::FillRect,
    ) -> bool {
        let mut did_update = false;
        let z_axis_off_cut = self.z_axis_off_cut + tool.length; 

        let increment = 2.0 * tool.radius * tool.offset;
        let mut first_time = true;
        let mut is_going_up = true;
        for x in float_loop(
            rect.min_x() + tool.radius,
            rect.max_x() - tool.radius,
            increment,
        ) {
            if first_time {
                println!("(RAPID)");
                let mut y = rect.min_y() + tool.radius;
                if (sign.y_values_before(x, y) % 2 == 0)
                    == do_cut_on_odd {

                    let mut assigned_y = false;
                    for i in 0..5 {
                        let (new_y, new_is_going_up) = match i {
                            1 => (sign.get_next_y_value(x, rect.min_y()) + tool.radius, true),
                            2 => (sign.get_next_y_value(x, rect.min_y()) - tool.radius, false),
                            3 => (sign.get_prev_y_value(x, rect.min_y()) + tool.radius, true),
                            4 => (sign.get_prev_y_value(x, rect.min_y()) - tool.radius, false),
                            5 => (sign.get_next_y_value(x, rect.max_y()) + tool.radius, true),
                            6 => (sign.get_next_y_value(x, rect.max_y()) - tool.radius, false),
                            7 => (sign.get_prev_y_value(x, rect.max_y()) + tool.radius, true),
                            8 => (sign.get_prev_y_value(x, rect.max_y()) - tool.radius, false),
                            _ => (y, is_going_up),
                        };
                        if (sign.y_values_before(x, y) % 2 == 0)
                            != do_cut_on_odd {
                            y = new_y;
                            is_going_up = new_is_going_up;
                            assigned_y = true;
                            break;
                        }
                    }

                    if !assigned_y {
                        return did_update;
                    }
                }
                self.cnc_router.move_to_coordinate_rapid(
                    &cnc_router::Coordinate::from(
                        x, y, z_axis_off_cut,
                    ),
                );
                self.cnc_router.move_to_optional_coordinate(
                    &cnc_router::OptionalCoordinate::from_z(
                        Some(z_axis_off_cut + self.depth_of_cut)
                    ),
                    Some(tool.feed_rate_of_drill), false
                );
                first_time = false;
            }
            else {
                // follow path tool.radius to left/right
                if (sign.y_values_before(x, self.cnc_router.get_pos().y) % 2 == 0)
                    == do_cut_on_odd {
                    println!("(UP)");
                    self.cnc_router.move_to_optional_coordinate(
                        &cnc_router::OptionalCoordinate::from_z(
                            Some(z_axis_off_cut)
                        ),
                        Some(tool.feed_rate_of_cut), false,
                    );
                    return did_update;
                }
                self.cnc_router.move_to_optional_coordinate(
                    &cnc_router::OptionalCoordinate::from_x(
                        Some(x)
                    ),
                    Some(tool.feed_rate_of_cut), false
                );
            }

            let mut y = if is_going_up {
                sign.get_next_y_value(x, self.cnc_router.get_pos().y) - tool.radius
            } else {
                sign.get_prev_y_value(x, self.cnc_router.get_pos().y) + tool.radius
            };
            if y < rect.min_y() {
                y = rect.min_y() + tool.radius;
            }
            else if y > rect.max_y() {
                y = rect.max_y() - tool.radius;
            }

            range_map.fill_rect(x-tool.radius, self.cnc_router.get_pos().y, x+tool.radius, y);
            did_update = true;

            if (sign.y_values_before(x, y) % 2 == 0)
                == do_cut_on_odd {
                println!("(UP)");
                self.cnc_router.move_to_optional_coordinate(
                    &cnc_router::OptionalCoordinate::from_z(
                        Some(z_axis_off_cut)
                    ),
                    Some(tool.feed_rate_of_cut), false,
                );
                return did_update;
            }
            self.cnc_router.move_to_optional_coordinate(
                &cnc_router::OptionalCoordinate::from_y(
                    Some(y)
                ),
                Some(tool.feed_rate_of_cut), false,
            );


            is_going_up = !is_going_up;
        }

        println!("(UP)");
        self.cnc_router.move_to_optional_coordinate(
            &cnc_router::OptionalCoordinate::from_z(
                Some(z_axis_off_cut)
            ),
            Some(tool.feed_rate_of_cut), false,
        );

        return did_update;
    }

    pub fn broad_smart_path<J : lines_and_curves::Intersection +
        std::fmt::Debug + Clone + cnc_router::CNCPath> (
        &mut self,
        do_cut_on_odd: bool,
        sign : sign::Sign<J>,
        tool: &cnc_router::Tool,
    ) {
        let mut sign = sign;

        let mut fill_rect = range_map::FillRect::from(
            sign.bounding_rect().min_x(), sign.bounding_rect().min_y(),
            sign.bounding_rect().max_x(), sign.bounding_rect().max_y()
        );

        let mut cleared = false;
        let mut count = 0.5;
        while !cleared {
            cleared = true;
            for (min_x, min_y, max_x, max_y) in fill_rect.get_open_rects() {
                if (max_x - min_x) * (max_y - min_y) < 0.1 { continue }
                let rect = lines_and_curves::Rectangle::from(
                    lines_and_curves::Point::from(min_x, min_y),
                    lines_and_curves::Point::from(max_x, max_y),
                );
                eprintln!(
                    "(START)\n(({}, {}) ({}, {}) LENGTH: {})",
                    min_x, min_y, max_x, max_y, (max_x - min_x) * (max_y - min_y)
                );
                cleared = false;
                if !self.cut_broad_rect(
                    do_cut_on_odd, &mut sign, tool, &rect, &mut fill_rect
                ) {
                    eprintln!("Force FILL");
                    fill_rect.fill_rect(min_x, min_y, max_x, max_y);
                    // cleared = true;
                    // break;
                } else {
                    eprintln!("Updated");
                }
            }

            count += 0.001;
        }

        eprintln!("VERY END");
        for rect in fill_rect.get_open_rects() {
            if rect.3 < 4.0 { continue }
            eprintln!("{:?} = {}", rect, (rect.2 - rect.0) * (rect.3 - rect.1));
        }
    }

    pub fn build_gcode_smart_path<J : lines_and_curves::Intersection +
        std::fmt::Debug + Clone + cnc_router::CNCPath> (
        &mut self,
        do_cut_on_odd: bool,
        signs : &Vec<sign::Sign<J> >,
    ) {
        self.cut_text(do_cut_on_odd, signs);

        let tools = self.cnc_router.get_tools().clone();
        for (tool_index, tool) in tools.iter().enumerate() {
            if !tool.is_broad() { continue }
            self.cnc_router.set_tool_and_go_home(tool_index, tool.feed_rate_of_cut);

            for sign in signs {
                eprintln!("LEN: {} = {}", sign.shapes().len(), sign.expand_lines(tool.radius, do_cut_on_odd).shapes().len());
                self.broad_smart_path2(
                    do_cut_on_odd,
                    sign.expand_lines(tool.radius, do_cut_on_odd),
                    // sign.clone(),
                    tool,
                );
            }
        }

        // self.cut_text(do_cut_on_odd, signs);
    }


    // MARK: Smart method 2

    pub fn cut_broad_smart_path2<J : lines_and_curves::Intersection +
        std::fmt::Debug + Clone + cnc_router::CNCPath> (
        &mut self,
        do_cut_on_odd: bool,
        sign : &mut sign::Sign<J>,
        tool: &cnc_router::Tool,
        fill_rect: &mut range_map::FillRect,
        x: f64,
        y: f64,
        increment: f64,
    ) {
        let mut sign = sign;
        let mut x = x;
        let mut y = y;

        if (sign.y_values_before(x, y) % 2 == 1)
            != do_cut_on_odd {
            return;
        } else if let Some((distance, _, shape)) = sign.closest_shape(
            &lines_and_curves::Point::from(x, y)
        ) {
            if distance < tool.radius {
                return;
            }
        }

        let z_axis_off_cut = self.z_axis_off_cut + tool.length; 

        let mut moved = false;
        let mut prev_i_move = 9999;
        'main: loop {
            let prev_x = x;
            let prev_y = y;
            let mut found_new_value = false;
            for i in 0..7 {
                if i == prev_i_move && i == 2 { continue; }
                if i >= 2 && !moved { continue }
                if i == 2 {
                    if !moved { continue }
                    if let Some((distance, _, shape)) = sign.closest_shape(
                        &lines_and_curves::Point::from(
                            self.cnc_router.get_pos().x, self.cnc_router.get_pos().y
                        )
                    ) {
                        // if distance > tool.radius + 0.00001 {
                        if distance > 0.1 {
                            continue;
                        }
                        let shape = shape.clone();
                        let mut new_lines = Vec::new();
                        for line in shape.lines() {
                            new_lines.push(line);
                        }

                        // println!("(FOLLOW PATH)");
                        cnc_router::CNCPath::cut_till::<T>(
                            &new_lines,
                            Some(self.cnc_router.get_pos().x + increment),
                            None,
                            &mut self.cnc_router,
                            Some(tool.feed_rate_of_cut),
                            false,
                            tool.feed_rate_of_drill,
                            self.z_axis_off_cut,
                            self.depth_of_cut,
                        );
                        // println!("(END PATH)");
                        let pos = self.cnc_router.get_pos();
                        x = pos.x;
                        y = pos.y;
                        prev_i_move = i;
                        continue 'main;
                    }
                    continue;
                }


                let (new_x, new_y) = match i {
                    0 => (x, sign.get_next_y_value(x, y+0.0001)),
                    1 => (x, sign.get_prev_y_value(x, y-0.0001)),
                    3 => (x + increment, y),
                    4 => (x - increment, y),
                    5 => (x, y + increment),
                    _ => (x, y - increment),
                };

                if (
                        ((x - new_x).abs() + (y - new_y).abs() + 0.0001) >= increment
                    ) &&
                    sign.sees_even_odd_lines_before(new_x, new_y, do_cut_on_odd, true) &&
                    sign.sees_even_odd_lines_before((new_x+x)/2.0, (new_y+y)/2.0, do_cut_on_odd, true) &&
                    // (
                    //     (sign.y_values_before(new_x, new_y) % 2 == 1)
                    //     == do_cut_on_odd
                    // ) &&
                    !sign.line_collides_wth_rect(
                        &lines_and_curves::Rectangle::from_rect_add_radius(
                            &lines_and_curves::Rectangle::from(
                                lines_and_curves::Point::from(x, y),
                                lines_and_curves::Point::from(new_x, new_y),
                            ),
                            -0.0001
                        )
                    ) &&
                    !fill_rect.is_fill_padding(
                        x, y,
                        new_x, new_y,
                        tool.radius, tool.radius,
                    )
                {
                    // println!("(i: {})", i);
                    x = new_x;
                    y = new_y;
                    found_new_value = true;
                    prev_i_move = i;
                    break;
                } 
            }
            if !found_new_value {
                if moved {
                    // println!("(FAILED)");
                    self.cnc_router.move_to_optional_coordinate(
                        &cnc_router::OptionalCoordinate::from_z(
                            Some(z_axis_off_cut),
                        ),
                        Some(tool.feed_rate_of_drill), false,
                    );
                }
                return;
            }

            if !moved {
                self.cnc_router.move_to_coordinate_rapid(
                    &cnc_router::Coordinate::from(
                        prev_x, prev_y, z_axis_off_cut,
                    ),
                );
                self.cnc_router.move_to_optional_coordinate(
                    &cnc_router::OptionalCoordinate::from_z(
                        Some(z_axis_off_cut + self.depth_of_cut),
                    ),
                    Some(tool.feed_rate_of_drill), false,
                );
                moved = true;
            }

            let min_x = if prev_x < x { prev_x } else { x };
            let max_x = if prev_x > x { prev_x } else { x };
            let min_y = if prev_y < y { prev_y } else { y };
            let max_y = if prev_y > y { prev_y } else { y };

            fill_rect.fill_rect(
                min_x-tool.radius, min_y-tool.radius,
                max_x+tool.radius, max_y+tool.radius,
            );
            self.cnc_router.move_to_optional_coordinate(
                &cnc_router::OptionalCoordinate::from(
                    Some(x),
                    Some(y),
                    None
                ),
                Some(tool.feed_rate_of_cut), false,
            );
        }
    }

    pub fn broad_smart_path2<J : lines_and_curves::Intersection +
        std::fmt::Debug + Clone + cnc_router::CNCPath> (
        &mut self,
        do_cut_on_odd: bool,
        sign : sign::Sign<J>,
        tool: &cnc_router::Tool,
    ) {
        let mut sign = sign;

        let mut fill_rect = range_map::FillRect::from(
            sign.bounding_rect().min_x(), sign.bounding_rect().min_y(),
            sign.bounding_rect().max_x(), sign.bounding_rect().max_y()
        );
        eprintln!("({}, {}) -> ({}, {})",
            sign.bounding_rect().min_x(), sign.bounding_rect().min_y(),
            sign.bounding_rect().max_x(), sign.bounding_rect().max_y()
        );

        let increment = 2.0 * tool.radius * tool.offset;
        let bounding_rect = sign.bounding_rect().clone();
        for x in float_loop(
            bounding_rect.min_x() + tool.radius,
            bounding_rect.max_x() - tool.radius,
            increment
        ) {
            for y in float_loop(
                bounding_rect.min_y() + tool.radius,
                bounding_rect.max_y() - tool.radius,
                increment
            ) {
                self.cut_broad_smart_path2(
                    do_cut_on_odd, &mut sign, &tool,
                    &mut fill_rect, x, y, increment,
                );
            }
        }

        eprintln!("VERY END");
        for rect in fill_rect.get_open_rects() {
            // if rect.3 < 4.0 { continue }
            eprintln!("{:?} = {}", rect, (rect.2 - rect.0) * (rect.3 - rect.1));
        }
    }

    pub fn cut_text<
        J : lines_and_curves::Intersection +
        std::fmt::Debug + Clone + cnc_router::CNCPath
    > (
        &mut self,
        do_cut_on_odd: bool,
        signs : &Vec<sign::Sign<J> >,
    ) {
        let tools = self.cnc_router.get_tools().clone();
        for (tool_index, tool) in tools.iter().enumerate() {
            if !tool.is_text() { continue }
            self.cnc_router.set_tool_and_go_home(tool_index, tool.feed_rate_of_cut);

            for sign in signs {
                let sign = sign.expand_lines(tool.radius, do_cut_on_odd);
                let shapes = sign.shapes().clone();
                for shape in shapes {
                    let mut new_lines = Vec::new();
                    for line in shape.lines() {
                        new_lines.push(line);
                    }
                    // let Some(point) = new_lines[0].start_path() else { continue };
                    // println!("(MOVE RAPID)");
                    // self.cnc_router.move_to_coordinate_rapid(
                    //     &cnc_router::Coordinate::from(
                    //         point.x, point.y, self.z_axis_off_cut,
                    //     )
                    // );

                    // self.cnc_router.move_to_optional_coordinate(
                    //     &cnc_router::OptionalCoordinate::from_z(
                    //         Some(self.z_axis_off_cut + self.depth_of_cut)
                    //     ),
                    //     Some(tool.feed_rate_of_drill), false,
                    // );

                    cnc_router::CNCPath::cut_till::<T>(
                        &new_lines,
                        None,
                        None,
                        &mut self.cnc_router,
                        Some(tool.feed_rate_of_cut),
                        true,
                        tool.feed_rate_of_drill,
                        self.z_axis_off_cut,
                        self.depth_of_cut,
                    );

                    self.cnc_router.move_to_optional_coordinate(
                        &cnc_router::OptionalCoordinate::from_z(
                            Some(self.z_axis_off_cut)
                        ),
                        Some(tool.feed_rate_of_drill), false,
                    );
                }
            }
        }
    }

    pub fn get_router(&self) -> &cnc_router::CNCRouter<T> {
        &self.cnc_router
    }

    pub fn get_router_mut(&mut self) -> &mut cnc_router::CNCRouter<T> {
        &mut self.cnc_router
    }
}

fn float_loop(start: f64, threshold: f64, step_size: f64) -> impl Iterator<Item = f64> {
    std::iter::successors(Some(start), move |&prev| {
        let next = prev + step_size;
        if prev >= threshold {
            None
        } else if next < threshold {
            Some(next)
        }
        else {
            Some(threshold)
        }
    })
}

